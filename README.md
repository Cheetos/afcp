# Algorithms for Competitive Programming

### Errata

* A fix to the source code for Maximum Bipartite Matching (BPM) was added. The limits of the for-loops needed to be corrected.  

### What is new in the second edition?

* Codes refactored following best practices.
* More problems and exercises.
* Chapters from the previous edition have been revised and updated.
* New chapter for miscellaneous problems, including:
  * 15-puzzle game
  * Towers of Hanoi
  * Gambler's Ruin
  * Magic squares.
* New algorithms and data structures.
  * Backtracking. Useful for NP problems.
  * Bitset. Data structure for handling bits.
  * Quickselect algorithm. To find the kth-smallest element.
  * Radix Sort. A sorting method based on the number of digits.
  * Lowest Common Ancestor (LCA). Application of the RMQ algorithm.
  * Hungarian algorithm. To find the bipartite matching of maximum cost.
  * Pick's theorem. To find the area of a polygon in a lattice.
  * Modular Multiplicative Inverse. Helpful to quickly compute combinations.
  * Josephus - O(k log n). A better approach to solving the Josephus problem.
  * Jarvis' Square Root. Algorithm to calculate the square root with specific precision.
  * Rabin-Karp algorithm. To find a pattern inside a string.
  * Sliding Window. Linear method to find consecutive elements with common characteristics.

In this repository you will find the solution for the exercises in the book and the algorithms in the appendices. Also we will frequently update the content with solutions for problems that we consider interesting. At this point the topics covered in the book are the following:

* Fundamentals (Recursion and bitwise)
* Data Structures
* Sorting Algorithms
* Divide and Conquer
* Dynamic Programming
* Graph Theory
* Geometry
* Number Theory and Combinatorics 
* String Manipulation

The goal of this book is to have in one place the algorithms that are frequently used in competitive programming, providing a brief description of the algorithms along with a source code to reinforce the learning. We know is impossible to list all existing algorithms, but this book is a good start.

